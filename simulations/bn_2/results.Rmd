---
title: "Simulation study: Sample DAGs with local structure"
subtitle: "Network: LDAG10. Contrasting parameters: graph prior / edge penalty and regularization"
author: "Vera Kvisgaard"
output: 
  html_document: 
    toc: true
---

Precision-recall of ancestor relation probabilities from simulations run on a 10 node labeled DAG, comparing different optimization routines for the local independence structures and the effect of the edge-penalization factor in the graph prior. 

***

#### Variables:

- `init` algorithm for initiating the search space of the MCMC chain..
- `struct` algorithm for optimizing the local structure of CPTs. 
- `sample` algorithm for sampling structures (`order` or `partition`)
- `epf` edge penalty, a penalty term `-length(parentnodes)*log(epf)` is added to the local marginal likelihoods.
- `regular` if `TRUE` the optimized local structures are forced to be regular. 
- `ess = 1`, equivalent sample size of Bdeu-prior.
- `hardlimit = 5`, maximum parent size.


#### Notes: 
- For each simulation run `r` and samplesize `N` (unintended), a random distribution over the structure is drawn and a data set sampled from the network. The same data set is used across all other params. 

# PREP


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      results = "hold",
                      cache = TRUE,
                      messages = FALSE,
                      warnings = FALSE)
```

```{r}
library(doSNOW)
library(foreach)
library(dplyr)
library(ggplot2)

simname <- "bn_2"
here::i_am(paste0("./simulations/", simname, "/results.Rmd"))

bnnames <- c("asia", "sachs", "child")
filepaths <- list.files(here::here("simulations", simname, "MCMCchains"), full.names = T)
names <- c("network", "init", "struct", "sample", "epf",  "regular", "N", "r")

```


```{r eval routines}

eval_files <- function(filepaths, bnname, prmethod, verbose = F) {
  
  indx <- grepl(bnname, filepaths, T)
  if (!all(indx)) stop("All files do not match bnname.")
  
  bn <- readRDS(here::here("./data/", paste0(bnname, ".rds")))
  n  <-  length(bn)
  dag  <- bnlearn::amat(bn)
  dmat <- bida:::descendants(bn)
  
  res <- foreach(f = filepaths, 
                 .combine  = "rbind",
                 .packages = "Matrix") %dopar% eval_MCMCchain(f, dag, dmat, n, prmethod, seq_len(200), verbose = verbose)
  
  cbind(as.list(filepaths), res)
}

eval_MCMCchain <- function(f, dag, dmat, n, prmethod, burninsamples, verbose = T) {
  if (verbose) cat(f)
  MCMCchain  <- readRDS(f)
  if ("smpl" %in% names(MCMCchain))  MCMCchain <- MCMCchain$smpl
 
  dindx <- diag(n) == 1
  dags <- lapply(MCMCchain$traceadd$incidence[-burninsamples], as.matrix)
  
  # list unique DAGs
  u    <- unique(dags)
  support  <- bida:::rowsum_fast(rep(1/length(dags), length(dags)), dags, u)
  dags <- u 
  dmats <- lapply(dags, bida:::descendants)
  
  # compute posterior edge probs
  edgep <- Reduce("+", Map("*", dags, support))[!dindx]
  ancp  <- Reduce("+", Map("*", dmats, support))[!dindx]
  
  res <- matrix(nrow = 2, ncol = 3)
  colnames(res) <- c("TPR", "FPR", "avgppv")
  rownames(res) <- c("edgep", "ancp")
  
  # edge probs
  n1 <- sum(dag)

  res[1, 1] <- sum(edgep[dag[!dindx] == 1])/n1
  res[1, 2] <- sum(edgep[dag[!dindx] == 0])/(n**2-n-n1)
  res[1, 3] <- ldags:::compute_avgppv(edgep, dag[!dindx], method = prmethod)
  
  # arp
  pr <- ldags:::compute_prec_recall(ancp, dmat[!dindx], method = prmethod)
  
  n1 <- sum(dmat)-n
  res[2, 1] <- sum(ancp[dmat[!dindx] == 1])/n1
  res[2, 2] <- sum(ancp[dmat[!dindx] == 0])/(n**2-n-n1)
  #res[2, 3] <- compute_avgppv(ancp, dmat)
  res[2, 3] <- pr$avgppv 
  
  list(edgep = edgep, 
       rates = res, 
       pr = pr$df,
       toc = as.matrix(attr(MCMCchain, "toc")))
  
}


res_to_df <- function(res, filepaths, names = c("network", "init", "struct", "sample", "epf", "regular", "N", 
"r")) {
  
  tmp <- stringr::str_split(filepaths, ".+MCMCchains/|_|.rds", simplify = F)
  par <- data.frame(do.call(rbind, tmp)[, seq_along(names)+1])
  colnames(par) <- names
  char_to_factor <- function(x, sub) {
    u <- unique(x)
    ordr <- order(as.numeric(gsub(sub, "", u)))
    factor(x, u[ordr])
  }
  par$N <- char_to_factor(par$N, "N")
  par$epf <- char_to_factor(par$epf, "epf")

  tmp <- do.call(rbind, res)
  if (nrow(tmp) == length(filepaths)) {
    return(cbind(par, tmp))
  } else {
    nrows <- vapply(res, nrow, integer(1))
    df <- cbind(par[rep.int(seq_along(filepaths), nrows), ], tmp)
    df$name <- rownames(tmp)
    return(df)
  }
}

```

```{r}
plot_box_plot <- function(df, x, y, title = "", fill = "struct", facets = "algo+name~network+epf") {
  plot <- ggplot(df, aes(x = !! sym(x), y = !! sym(y), fill = !! sym(fill))) +
    facet_grid(as.formula(facets), scales = "free", space = "free") +
    geom_boxplot() +
    ggtitle(title) +
    theme(legend.position = "bottom")
  
  if (fill == "struct") plot <- plot + scale_fill_manual(values = c(dag = "green", ldag = "red", tree = "blue"))
  return(plot)
}
plot_prec_recall <- function(df, title = "", facets = "algo+struct+epf~network+N") {
  rate <- df$PPV[nrow(df)]
  ggplot(df, aes(TPR, PPV, group = r)) +
    facet_grid(as.formula(facets)) +
    geom_line() +
    geom_hline(yintercept = rate, color = "red") +
    ggtitle(title)
}
plot_prec_recall_step <- function(df, title = "", facets = "algo+struct+epf~network+N") {
  rate <- df$PPV[nrow(df)]
  ggplot(df, aes(TPR, PPV, group = r)) +
    facet_grid(as.formula(facets)) +
    geom_hline(yintercept = rate, color = "red") +
    geom_step(direction = "vh") +
    geom_point(data = dplyr::filter(df, !is.infinite(df$x)),
               color = "blue", size = .5) +
    ggtitle(title)
}



plot_res <- function(filepaths) {
  
}
```


Compute precision recall of each sample of DAGs
```{r load res, cache = T}
cl <- makeCluster(5, "SOCK", outfile = "")
export <- as.vector(lsf.str(envir = .GlobalEnv))
clusterExport(cl, export)
registerDoSNOW(cl)

res <- list()
for (bnname in bnnames) {
  indx <- grepl(bnname, filepaths)
  stopifnot(any(indx))
  res[[bnname]] <-  eval_files(filepaths[indx], bnname, prmethod = "noise", verbose = T)
}



```

Count number of runs for each setting>
```{r}

df <- res_to_df(as.list(seq_along(filepaths)), filepaths, names)
head(df)
tidyr::pivot_wider(aggregate(rep(1, nrow(df)), df[, names[!names == "r"]], sum), 
                   names_from = "struct", values_from = "x") %>%  print(n = 100)


```





# AVERAGE PRECISION, TRUE AND FALSE POSITIVES 
Across edge penalty `epf` and regularity `reg`:
```{r}
for (bnname in bnnames) {
  df <- res_to_df(res[[bnname]][, "rates"], unlist(res[[bnname]][, 1]), names)

  facets <- "init+sample+N~network+struct"
  for (y in c("avgppv", "TPR", "FPR")) {
    plot <- plot_box_plot(df, x = "epf", y = y, fill = "regular", facets = facets) + ylim(0, 1) 
    print(plot)
  }

}

```



# PRECISION RECALL CURVES ---
```{r PR-curves}

indx <- grepl("_epf1_|_epf10_|_epf100_", filepaths) & grepl("_N1000_", filepaths)
df <- res_to_df(res[indx, 3], filepaths[indx], names)

for (x in unique(df$init)) {

    facets <- "init+epf+sample~N+struct+regular"
    indx <- df$init == x 
    plot <- plot_prec_recall(df[indx, ], facets = facets)
    print(plot)
  
}
```



# RUN TIMES 
```{r}

df <- res_to_df(res[, 4], filepaths, names)
facets <- "name~init+regular+epf+sample"

for (x in unique(df$init)) {
  indx <- df$init == x 
  plot <- plot_box_plot(df[indx, ],  x = "N", y = "tmp", fill = "struct", facets = facets)
  print(plot)
}
```

```{r}
stopCluster(cl)
```

