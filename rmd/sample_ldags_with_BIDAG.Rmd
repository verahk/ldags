---
title: 'Toy example: sample LDAGs'
author: "Vera Kvisgaard"
date: "2024-04-25"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

```

This note test how the `BiDAG` package can be manipulated used to sample LDAGs. 
Use the Asia network. 

```{r}
here::i_am("./rmd/sample_ldags_with_BIDAG.Rmd")
bn <- readRDS(here::here("./data/asia.rds"))
df <- bnlearn::rbn(bn, 1000)
data <- sapply(df, as.numeric) -1
nlev <- sapply(df, nlevels)
dmat <- bida:::descendants(bn)
```

Define a score-function that can be used with `BiDAG`. 
Need to assign this function to the namespace of the package, otherwise an internal function is called (..).
```{r}
library(BiDAG)
usrDAGcorescore <- function(j, parentnodes, n, param) {
  famscore_csi_from_data(param$data, nlev, j, parentnodes, ess = 1, kappa = .5)
}
assignInNamespace("usrDAGcorescore", usrDAGcorescore, ns = "BiDAG")
```

Specify a `BiDAG::scoreparameters` for LDAGs and standard (discrete) DAGs.
```{r}
scorepar <- list()

scorepar$LDAG <- scoreparameters("usr", 
                         data = data,
                         usrpar = list(pctesttype = "bdecat"))
scorepar$LDAG$Cvec <- nlev # required to run PC-algo with "bdecat" options, in search for initial search space.

scorepar$DAG <- scoreparameters("bdecat", 
                          data = df,
                          bdecatpar = list(chi = 1, edgepf = 1))
```

## Check convergence of MCMC-chain. 
Run MCMC using the three algorithms `"order", "orderIter", "partition"` twice, and compare the resulting edge probabilities. True edges are marked in blue.
```{r}
indx <- bnlearn::amat(bn) == 1
par(mfrow = c(2, 3))
for (x in c("DAG", "LDAG")) {
  for (algo in c("order", "orderIter", "partition")) {
  smpls <- replicate(2, sampleBN(scorepar[[x]], algo, verbose = F), simplify = FALSE)
  edgep <- lapply(smpls, edgep)
  plot(edgep[[1]], edgep[[2]], 
       ylim = c(0, 1), xlim = c(0,1),
       main = paste0(x, " + ", algo))
  points(edgep[[1]][indx], edgep[[2]][indx], col = "blue")
  abline(a = 0, b = 1, col = "red")
  }
}

```



```{r}

# replicate BIDAG::edgep for iterativeMCMC trace-add. 
# Not sure why this include multiple lists with sampled DAGs..
compute_arp <- function(MCMCchain) {
  ln <- length(MCMCchain$traceadd[[1]])
  MCMCchain$traceadd[[1]] <- c(MCMCchain$traceadd[[1]][[ln - 
                1]], MCMCchain$traceadd[[1]][[ln]])
  
  ln <- length(MCMCchain$traceadd$incidence)
  dmats <- lapply(MCMCchain$traceadd$incidence[seq.int(ceiling(.2*ln), ln)], function(dag) bida:::descendants(as.matrix(dag)))
  Reduce("+", dmats)/length(dmats)
}

samplesizes <- round(10**seq(2, 4, length.out = 10))
rmses <- matrix(nrow = length(samplesizes), ncol = 2)
colnames(rmses) <- c("DAG", "LDAG")
for (i in seq_along(samplesizes)) {
  cat("\n samplesize:", samplesizes[i], " ")
  # sample data
  #df <- bnlearn::rbn(bn, samplesizes[i])
  data <- bida:::sample_data_from_bn(bn, samplesizes[i])
  df   <- data.frame(apply(data, 2, factor, exclude = NULL, simplify = F))
  nlev <- sapply(df, nlevels)
  
  # define score par
  scorepar <- list()
  scorepar$DAG <- scoreparameters("bdecat", 
                            data = df,
                            bdecatpar = list(chi = 1, edgepf = 1))
  scorepar$LDAG <- scoreparameters("usr", 
                           data = data,
                           usrpar = list(pctesttype = "bdecat"))
  scorepar$LDAG$Cvec <- nlev 
  
  
  # sample DAGs and compute ARP
  cat("smpl ")
  smpls <- lapply(scorepar, sampleBN, algo = "orderIter")
  
  cat("compute ARP ")
  arps <- lapply(smpls, compute_arp)
  
  # rmse 
  rmses[i, ] <- vapply(arps, function(x) sqrt(mean( (x-dmat)**2 )), numeric(1))
}

matplot(samplesizes, rmses, type = "l", log = "x")
               
```



