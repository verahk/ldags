% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/optimize_partition.R,
%   R/optimize_partition_ldag.R, R/optimize_partition_tree.R
\name{optimize_partition}
\alias{optimize_partition}
\alias{optimize_partition_from_cpt}
\alias{optimize_partition_ldag}
\alias{optimize_partition_tree}
\title{Optimize partition over parent outcome space}
\usage{
optimize_partition(
  counts,
  levels,
  ess,
  method,
  regular = F,
  min_score_improv = 0,
  verbose = FALSE
)

optimize_partition_from_cpt(cpt, ess, method, regular = T, return_cpt = TRUE)

optimize_partition_ldag(
  counts,
  levels,
  ess,
  regular,
  min_score_improv = 0,
  P = as.list(1:nrow(counts) - 1),
  labels = rep(list(integer()), length(levels)),
  conf = as.matrix(expand.grid(levels)),
  verbose = FALSE
)

optimize_partition_tree(
  counts,
  levels,
  ess = 1,
  min_score_improv = 0,
  verbose = verbose
)
}
\arguments{
\item{counts}{(integer matrix)
a frequency table.}

\item{levels}{(list of integer vectors)
levels of each conditioning variable in \code{counts},
such that \code{expand.grid(levels)} gives the joint configurations corresponding
to each row in \code{counts}.}

\item{ess}{(numeric)
imaginary sample size for the bdeu-prior.}

\item{method}{(character)}

\item{regular}{(logical)
if \code{FALSE} (default) the optimized partition is returned, also if it implies
conditional independencies (is not "regular"). If \code{TRUE} each part of the
optimized partition is divided by the outcomes of the relevant variables.
See \code{\link[=make_regular]{make_regular()}}.}

\item{verbose}{(logical)}
}
\value{
a list with named elements:
\itemize{
\item \code{partition}: the partition implied by the tree
\item \code{scores}: each part's contribution to the local score
\item additional output from the different optimization procedures.n
}
}
\description{
Optimize a regression-tree partitioning of the conditional outcome space.
}
\examples{
# ldag
levels <- list(0:1, 0:1)
counts <- cbind(c(10, 20, 30, 40), rep(10, 4))
optimize_partition_ldag(counts, levels, ess = 1, regular = T, verbose = T)

# mixed cardinality
levels <- list(0:1, 0:2)
counts <- cbind(10, 1, c(10, 10, 10**2, 10**2, 10**3, 10**3))
res <- optimize_partition_ldag(counts, levels, ess = 1, verbose = T)
cbind(expand.grid(levels), n = counts, part = get_parts(res$partition))

# binary tree
levels <- list(0:1, 0:1)
counts <- cbind(10, c(10**2, 10**2, 10**3, 10**3))
res <- optimize_partition_tree(counts, levels, verbose = TRUE)
cbind(counts, get_parts(res$partition))

counts <- cbind(5, c(10**2, 10**2, 10**3, 10**3))
res <- optimize_partition_tree(counts, levels, verbose = TRUE)
res2 <- optimize_partition_tree(counts, levels, min_score_improv = -5, verbose = TRUE)
cbind(counts, get_parts(res$partition), get_parts(res2$partition))


# mixed cardinality
levels <- list(0:1, 0:2)
counts <- cbind(1, 10, c(10, 10, 10**2, 10**2, 10**3, 10**3))
res <- optimize_partition_tree(counts, levels, verbose = T)
cbind(expand.grid(levels), n = counts, part = get_parts(res$partition))

# compare returned scores with score of partition
gr <- get_parts(res$partition)
tmp <- rowsum(counts, gr)
scores <- famscore_bdeu_byrow(tmp, 1, r = ncol(counts), q = nrow(counts), s = lengths(res$partition))
all.equal(unname(scores), res$scores)


}
